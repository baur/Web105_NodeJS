/*
- объявляем константу url
- присваиваем (в виде ссылки) глобальный модуль url
- url нужен для извлечения информации из url
? почему не указан protocol, host, port
Url {
  protocol: null,
  slashes: null,
  auth: null,
  host: null,
  port: null,
  hostname: null,
  hash: null,
  search: '?fdfd',
  query: 'fdfd',
  pathname: '/ddd',
  path: '/ddd?fdfd',
  href: '/ddd?fdfd'
}
*/
const url = require("url");

/*
- Объявляем константу route_handler
- Присваиваем (в виде ссылки) модуль route_handler (router\node_modules\route_handler\index.js)
- route_handler отвечает за реакцию на конкретные запросы клиентов
*/
const route_handler = require("route_handler");

const route = {
	/*подписываем заголовок ответа */
	showHead: function(code) {
		this.response.writeHead(code,{"Content-Type":"text/html"})
	},
	/*тело ответа */
	write: function(data) {
		this.response.write(data);
	},
	/*завершаем сессию*/
	end: function(){
		this.response.end();
	},
	/*вызывается, когда получаем запрос от клиента*/
	init: function(request,response){
		/*получаем ссылку на request, response */
		this.request = request;
		this.response = response;
		/*вызываем маршрутизатор запросов*/
		this.route();
	},
	/*маршрутизатор запросов*/
	route: function(){
        /*получаем путь запроса*/
		var path = url.parse(this.request.url);
		/*очищаем путь и будем считать, что это имя метода контроллера*/
		var controller = path.pathname.replace(/\//g,"");
        /*переменный для ответа*/
		var result = '';
		/*
		- сохраняем текущий контекст для передачи вложенным методам
		? а почему не использовали этот переменный*/

		var self = this;

		/* callbakc функция для вывода результата в консоль сервера*/
		var result = function(res) {
			console.log(res);
		}

		/*если запрос пуст, то будем считать, что клиент обратился домашней странице и присваиваем  
		соответствующе название метода котроллера*/

		if (!controller) controller = 'index';
		/*
		- если путь запроса не пустой, то проверяем содержаться ли котроллер соответствующий метод
		- если нет, то немедленно выходим из текущей функции передавая управление в error
		*/
		if (typeof route_handler[controller] != 'function') return this.error(404);
		this.showHead(200);
		/*вызываем соответствующий метод контроллера, при этом передаем весть текущий контекст
		- а также передаем функцию result в виде callback*/
		route_handler[controller](result, this);
	},
	error:function(code){
		this.showHead(code);
		this.write("<h1>Sorry error " + code+";( </h1>");
		this.end();
		return;
	}
}

module.exports.route = route;